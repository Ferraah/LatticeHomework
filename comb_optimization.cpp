#include <iostream>
#include <stack>
#include <vector>
#include <cstring>
#include <utility>
#include <chrono>
#include <algorithm>
#include "parser.hpp"
#include "bool_matrix.hpp"

//typedef std::vector<std::vector<bool>> Domains;


bool ENABLE_LOGGING = true;

// N-Queens node
struct Node {

    int depth; // depth in the tree

    // Bool matrix for the domains of each variable
    BoolMatrix domains;

    // Initialize the domains for each variable
    Node(size_t N, int *u): depth(0), domains(N, 0, nullptr) {

        // Total elements if the domain matrix
        size_t size = 0; 

        // Biggest domain size
        size_t max_u = 0;
        for (int i = 0; i < N; i++){

            if (u[i]+1 > max_u){
                max_u = u[i] + 1;
            }

            // Upperbounds are included in the domain so we add 1
            size += u[i] + 1; 
        }

        // Allocate memory for the domain matrix and initialize it to true
        bool *host_data = new bool[size]; 
        memset(host_data, 1, size);

        // Initialize the domain matrix wrapper
        domains = BoolMatrix(N, max_u, host_data);

    }

    Node(const Node&) = default;
    Node(Node&&) = default;
    Node() = default;
};

void log_info(const std::string &message) {
    if (ENABLE_LOGGING) {
        std::cout << "[INFO] " << message << std::endl;
    }
}

void print_domains(BoolMatrix &domains){
    if(!ENABLE_LOGGING)
        return;
        
    for(int i = 0; i < domains.rows; i++){
        std::cout << "Domain of variable " << i << ": ";
        for(int j = 0; j < domains.cols; j++){
            std::cout << domains[i][j] << " ";
        }
        std::cout << std::endl;
    }
}


 
/**
 * @brief Update the domains given the constraints
 * @reture true if the domains were updated
 */
bool update_domains(BoolMatrix &domains, BoolMatrix& new_domains, int **C){

    bool updated = false;

    new_domains = BoolMatrix(domains);

    // Vector containing the index of the rows containing 
    // only one true value
    std::vector<std::pair<size_t, size_t>> unique_true_values;

    // For each row, find the index of the unique true value 
    for(int i = 0; i < domains.rows; i++){
        int j = domains.find_unique_true_index(i);

        // -1 means multiple true values found
        if(j == -1)
            continue;

        // Save the pair (i, j) where i is the row index and j is the column index
        unique_true_values.push_back(std::make_pair(i, j));
    }

    // For each pair (i, j) in the vector
    for(auto& p : unique_true_values){
        int i = p.first;
        int j = p.second;

        // If there is a constraint between i and k, then I remove the value
        // at column j from the domain of the variables k that have a constraint
        for(int k = 0; k < domains.rows; k++){
            if(C[i][k] == 1){
                if(new_domains[k][j]){
                    new_domains[k][j] = false;
                    updated = true;
                }
            }
        }

    }

    return updated;
}

/**
 * @brief Generate children nodes by branching on the variable_i
 * @param parent: Parent node
 * @param variable_i: Variable to branch on
 * @param C: Constraints matrix
 * @return Children nodes
 */
std::vector<Node> generate_children(const Node& parent, int variable_i, int **C){

    // Children nodes generated by branching on the variable_i
    std::vector<Node> children;

    BoolMatrix d = parent.domains;
    size_t rows = d.rows;
    size_t cols = d.cols;

    for(int j = 0; j < cols; j++){
        if(d[variable_i][j] == true){
            Node child(parent);
            child.depth  = parent.depth + 1;
            // Set the domain of the variable to be all zero apart from the unique valuec
            memset(child.domains[variable_i], 0, cols);
            child.domains[variable_i][j] = 1;
            children.push_back(std::move(child));
        }
    }

    return children;
}

/**
 * @brief Evaluate the node and branch if solution is not found
 * @param parent: Parent node
 * @param stack: Stack of other nodes
 * @param C: Constraints matrix
 * @param tree_loc: Number of nodes explored so far
 * @param num_sol: Number of solutions found so far
 */
void evaluate_and_branch(Node& parent, std::stack<Node>& stack, int **C, size_t& tree_loc, size_t& num_sol){

    // Copy node so we can update the domains
    Node updated_parent(parent);
    int curr_depth = parent.depth;
    int n = parent.domains.rows; 

    log_info("Evaluating node at depth " + std::to_string(curr_depth));

    // If we are at the last variable and the domain has only one value,
    // because we have branched duing last iteration. It means that this is a solution.
    if(curr_depth == n){
        log_info("Solution found!");
        num_sol++;
        return;
    }

    // Fixpoint: Update the domains until we can't update them anymore
    bool updated = false;
    do{
        log_info("Updating domains...");
        updated = update_domains(updated_parent.domains, updated_parent.domains, C);
        print_domains(updated_parent.domains);

        // Continue to update the domains until no restriction can be applied
    }while(updated);

    log_info("Updated domains: ");
    print_domains(updated_parent.domains);

    // -- To continue, we necessarily need to branch --

    // Generate branches from current variable domain (curr_depth is also current variable index)
    std::vector<Node> children = generate_children(updated_parent, curr_depth, C);

    log_info("Number of children: " + std::to_string(children.size()));

    for(int i = 0; i < children.size(); i++){
        log_info("Pushing child " + std::to_string(i) + " with domain: ");
        print_domains(children[i].domains);
        stack.push(std::move(children[i]));
        tree_loc++;
    }
}

int main(int argc, char *argv[]){

    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <filename>" << std::endl;
        return 1;
    }

    std::string filename = argv[1];
    Data data;
    if (data.read_input(filename.c_str())){
        data.print_n();
        data.print_u();
        data.print_C();
    } else {
        std::cerr << "Failed to read input file: " << filename << std::endl;
        return 1;
    }

    // Number of variables
    int n = data.get_n();
    int *u = data.get_u();
    int **C = data.get_C();

    // Nodes tree
    std::stack<Node> stack;

    Node root(n, u);
    stack.push(std::move(root));

    print_domains(stack.top().domains);

    // Counters
    size_t explored_nodes = 0;
    size_t explored_sol = 0;

    // Domains for each variable
    while(stack.size() != 0){
        Node current(std::move(stack.top()));
        stack.pop();
        evaluate_and_branch(current, stack, C, explored_nodes, explored_sol);
    }

    std::cout << "Number of solutions: " << explored_sol << std::endl;
    std::cout << "Number of nodes explored: " << explored_nodes << std::endl;

    return 0;
}
